#Alavue: Open Secure Distributed Remote Backup

#Copyright: 2011-2012, Rick Battle <rick.battle@solmera.com>

#This file is part of alavue.

#Alavue is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#Alavue is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with Alavue.  If not, see <http://www.gnu.org/licenses/>.

#!/bin/bash

./alavue.settings

#TODO replace the following with a pull from settings file
ROOT_PATH=/home/detaos/alavue_test_files/*
ALAVUE_PATH=/home/detaos/.alavue
FILE_DB="$ALAVUE_PATH"/file_db
KEY=~/.ssh/id_rsa.pub
#END settings needing to be pulled
TIME=`date +%s`

shopt -s nullglob

#check for public key
if [ ! -f $KEY ]; then
	echo "alavue requires a key pair to function properly.  Please generate one and retry."
	exit
fi

#check for existence of alavue directory
if [ ! -d "$ALAVUE_PATH" ]; then
	echo "creating .alavue directory"
	mkdir "$ALAVUE_PATH"
fi

#check for existence of file database
if [ ! -f "$FILE_DB" ]; then
	echo "creating file_db"
	touch "$FILE_DB"
	sqlite3 "$FILE_DB" <<SQL_CREATE
CREATE TABLE files (
	fid INTEGER PRIMARY KEY,
	path TINYTEXT KEY ASC NOT NULL,
	updated UNSIGNED INTEGER NOT NULL,
	name TINYTEXT
);
SQL_CREATE
fi

function upload() {
	echo "storing updated copy in the cloud"
	#encrypt
	cp "$1" "$1".enc	# TODO actually encrypt
	#MxN split
	split -n 2 "$1".enc "$2".	# TODO actually do an MxN split
	#upload
	#scp "$2".aa username@server1.com:/$remote_path/alavue # TODO
	#scp "$2".ab username@server2.com:/$remote_path/alavue # TODO
	#clean up from encryption and split
	rm "$1".enc
	rm "$2".aa
	rm "$2".ab
	#update database
	#sqlite3 "$FILE_DB" UPDATE files SET ('updated'="$TIME") WHERE 'path'="$f"
}

function process() {
	#if new, add file to database
	sql_res=`sqlite3 "$FILE_DB" "SELECT * FROM files WHERE path='$f'"`
	if [ "$sql_res" == "" ]; then
		echo "adding file to database"
		cloud_name=`openssl dgst -sha1 -hex "$f"`
		IFS=' ' read -ra cloud_name <<< "$cloud_name"
		cloud_name="${cloud_name[${#cloud_name[@]}-1]}"
		echo "$cloud_name"
		sqlite3 "$FILE_DB" "INSERT INTO files (path, updated, name) VALUES ('$f', 0, '$cloud_name')"
		sql_res=`sqlite3 "$FILE_DB" "SELECT * FROM files WHERE path='$f'"`
	fi
	IFS='|' read -ra sql_res <<< "$sql_res"
	#sql select output format: fid|path|updated|name
	backup_time="${sql_res[2]}"
	modified=`stat -c %Y "$f"`
	#if previous backup time < modified time, ie backup is older than file
	if [ "$backup_time" -lt "$modified" ]; then
		upload "$f" "${sql_res[3]}"
	fi
}

#recursively loop though root local directory and all subdirectories
function scan() {
	for f in "$@"
	do
		if [ -d "$f" ]; then
			scan "$f"/*
		else
			echo "Processing: $f"
			process "$f"
		fi
	done
}

scan $ROOT_PATH

#check for file deletions
sql_res=`sqlite3 "$FILE_DB" "SELECT * FROM files"`
IFS=$(echo -en "\n\b")
for entry in $sql_res
do
	IFS='|' read -ra entry <<< "$entry"
	#sql select output format: fid|path|updated|name
	f="${entry[1]}"
	if [ ! -f "$f" ]; then #path does not exist
		# TODO delete pieces from cloud
		echo "delete $f"
		sqlite3 "$FILE_DB" "DELETE FROM files WHERE path='$f'"
	fi
done
# TODO upload file_db
